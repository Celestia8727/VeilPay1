import { keccak256, toUtf8Bytes } from 'ethers'
// @ts-ignore - elliptic doesn't have great TypeScript support
import { ec as EC } from 'elliptic'

const ec = new EC('secp256k1')

/**
 * Generate domain hash from domain name
 * @param domainName - The domain name (e.g., "alice.veil")
 * @returns bytes32 hash of the domain
 */
export function generateDomainHash(domainName: string): `0x${string}` {
    return keccak256(toUtf8Bytes(domainName)) as `0x${string}`
}

/**
 * Derive REAL elliptic curve public keys from wallet signature
 * This creates deterministic keys that can be regenerated by signing the same message
 * @param walletClient - The wallet client to use for signing
 * @param message - The message to sign (defaults to key generation message)
 * @returns Object containing spend and view public keys (real EC points)
 */
export async function derivePublicKeyFromWallet(
    walletClient: any,
    message: string = "Generate stealth address keys"
): Promise<{ spendPubKey: `0x${string}`, viewPubKey: `0x${string}` }> {
    try {
        // Sign a deterministic message
        const signature = await walletClient.signMessage({
            account: walletClient.account,
            message
        })

        console.log('ðŸ”‘ Deriving REAL EC keypairs from signature...')

        // Derive two different private key seeds from the signature
        const sigHex = signature.slice(2) // Remove 0x prefix
        const spendSeed = keccak256('0x' + sigHex)
        const viewSeed = keccak256(keccak256('0x' + sigHex))

        console.log('   Spend seed:', spendSeed.slice(0, 20) + '...')
        console.log('   View seed:', viewSeed.slice(0, 20) + '...')

        // Generate REAL EC keypairs from the seeds
        const spendKeyPair = ec.keyFromPrivate(spendSeed.slice(2), 'hex')
        const viewKeyPair = ec.keyFromPrivate(viewSeed.slice(2), 'hex')

        // Get uncompressed public keys (0x04 + 64 bytes)
        const spendPubKey = ('0x' + spendKeyPair.getPublic(false, 'hex')) as `0x${string}`
        const viewPubKey = ('0x' + viewKeyPair.getPublic(false, 'hex')) as `0x${string}`

        console.log('âœ… Generated REAL EC public keys:')
        console.log('   Spend pub key:', spendPubKey.slice(0, 20) + '... (length:', spendPubKey.length, ')')
        console.log('   View pub key:', viewPubKey.slice(0, 20) + '... (length:', viewPubKey.length, ')')

        // Verify they're valid EC points
        try {
            ec.keyFromPublic(spendPubKey.slice(2), 'hex')
            ec.keyFromPublic(viewPubKey.slice(2), 'hex')
            console.log('âœ… Keys validated as real EC points!')
        } catch (e) {
            throw new Error('Generated keys are not valid EC points!')
        }

        return { spendPubKey, viewPubKey }
    } catch (error) {
        console.error('Error deriving public keys:', error)
        throw new Error('Failed to derive public keys from wallet')
    }
}

/**
 * Validate public key format
 * @param pubKey - Public key to validate
 * @returns true if valid
 */
export function isValidPublicKey(pubKey: string): boolean {
    // Must be 65 bytes (130 hex chars + 0x prefix)
    if (pubKey.length !== 132) return false
    // Must start with 0x04 (uncompressed format)
    if (!pubKey.startsWith('0x04')) return false
    // Must be valid hex
    return /^0x04[0-9a-fA-F]{128}$/.test(pubKey)
}

/**
 * Format address for display
 * @param address - Ethereum address
 * @returns formatted address (0x1234...5678)
 */
export function formatAddress(address: string): string {
    if (!address || address.length < 10) return address
    return `${address.slice(0, 6)}...${address.slice(-4)}`
}

/**
 * Format hash for display
 * @param hash - Hash string
 * @returns formatted hash
 */
export function formatHash(hash: string): string {
    if (!hash || hash.length < 10) return hash
    return `${hash.slice(0, 10)}...${hash.slice(-8)}`
}
